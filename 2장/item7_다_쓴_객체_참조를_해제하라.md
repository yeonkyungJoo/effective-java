# item7. 다 쓴 객체 참조를 해제하라

- 자바는 GC가 있기 때문에 메모리 관리에 대해 신경쓰지 않아도 될 거라 생각하기 쉽지만 그렇지 않다.
- 사용하지 않는 객체는 null로 설정해서 다음 GC가 발생할 때 레퍼런스가 정리되게 한다. 그렇다고 필요없는 객체를 볼 때마다 null로 설정하는 코드를 작성하지는 말자. 객체를 null로 설정하는 건 예외적인 상황에서나 하는 것이지 평범한 일이 아니다.
- **필요없는 객체 레퍼런스를 정리하는 최선책은 그 레퍼런스를 가리키는 변수를 특정한 범위(스코프) 안에서만 사용하는 것이다.** 로컬 변수는 해당 영역을 벗어나면 쓸모 없어져서 정리되기 때문.
- 그럼 언제 레퍼런스를 null로 설정해야 하는가? **메모리를 직접 관리할 때. (필요없는 것인지 프로그래머만 알 수 있을 때)**
- 메모리를 직접 관리하는 클래스는 프로그래머가 메모리 누수를 조심해야 한다.

##### 캐시
- 캐시를 사용할 때도 메모리 누수 문제를 조심해야 한다. 객체의 레퍼런스를 캐시에 넣어놓고 캐시를 비우는 것을 잊기 쉽다.
- WeakHashMap : 캐시의 키에 대한 레퍼런스가 캐시 밖에서 필요 없어지면 해당 엔트리를 캐시에서 자동으로 비워준다.
- 또는 특정 시간이 지나 캐시값이 의미가 없어지는 경우에 백그라운드 쓰레드를 사용하거나, 새로운 엔트리를 추가할 때 부가적인 작업으로 기존 캐시를 비우는 일을 할 것이다. (LinkedHashMap 클래스는 removeEldestEntry라는 메서드를 제공한다.)

##### 콜백
- 흔하게 메모리 누수가 발생할 수 있는 지점으로 리스너와 콜백이 있다.
- 클라이언트 코드가 콜백을 등록할 수 있는 API를 만들고 콜백을 뺄 수 있는 방법을 제공하지 않는다면, 계속해서 콜백이 쌓이기만 할 것이다. 이것 역시 WeahHashMap을 사용해서 해결할 수 있다.
- 메모리 누수는 발견하기 쉽지 않기 때문에 수년간 시스템에 머물러 있을 수도 있다. 코드 인스택션이나 heap profiler 같은 디버깅 툴을 사용해서 찾아야 한다. 따라서 이런 문제를 예방하는 방법을 학습하여 미연에 방지하는 것이 좋다.
